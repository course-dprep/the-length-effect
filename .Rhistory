<<<<<<< Updated upstream
) %>%
arrange(desc(n))
title.basics_clean %>%
filter(titleType == "tvMovie", !is.na(runtimeMinutes), runtimeMinutes >= 40) %>%
summarise(
count = n(),
mean_runtime = mean(runtimeMinutes),
median_runtime = median(runtimeMinutes)
)
# Checking variable type
dplyr::glimpse(title.basics[, c("primaryTitle", "startYear", "runtimeMinutes")])
sapply(title.basics[, c("primaryTitle", "startYear", "runtimeMinutes")], typeof)
dplyr::glimpse(title.ratings[, "averageRating", drop = FALSE])
sapply(title.ratings[, "averageRating", drop = FALSE], typeof)
# Replace "\N" and "" with NA
=======
scale_color_manual(values = c("Stadspark" = "red",
"Sint-Andries" = "blue",
"Centraal Station" = "green")) +
theme_minimal()
dev.off()
# PLOT ALL
## import the data from `gen/data-preparation/aggregated_df.csv`
df <- read_csv("aggregated_df.csv")
## group by date and calculate the sum of all reviews across neighbourhoods.
df_groupby <- df %>% group_by(date) %>% summarise(num_reviews = sum(num_reviews))
## plot the chart and store the visualisation.
pdf("plot_all.pdf")
ggplot(df_groupby, aes(x = date, y = num_reviews)) +
geom_line(color = "black", size = 1) +
labs(
x = "",
y = "Total number of reviews",
title = "Effect of COVID-19 pandemic on Airbnb review count"
) +
theme_minimal()
dev.off()
# Load packages
library(tidyverse)
library(ggplot2)
# DOWNLOAD DATA
## Function to download data and save as CSV
download_data <- function(url, filename){
download.file(url = url, destfile = paste0(filename, ".csv"))
}
url_listings <- "http://data.insideairbnb.com/belgium/vlg/antwerp/2021-02-25/visualisations/listings.csv"
url_reviews <- "http://data.insideairbnb.com/belgium/vlg/antwerp/2021-02-25/visualisations/reviews.csv"
download_data(url_listings, "listings")
download_data(url_reviews, "reviews")
# CLEAN DATA
reviews <- read_csv("reviews.csv")
listings <- read_csv("listings.csv")
## filter for reviews published since 01/01/2015
reviews_filtered <- reviews %>% filter(date > "2015-01-01")
## filter for `listings` that have received at least 1 review.
listings_filtered <- listings %>% filter(number_of_reviews > 1)
## merge the `reviews` and `listings` dataframes on a common columns (the type of join doesn't really matter since we already filtered out listings without any reviews)
df_merged <- reviews_filtered %>% inner_join(listings_filtered, by = c("listing_id" = "id"))
## group the number of reviews by month and neighborhood.
df_grouped <- df_merged %>%
mutate(month = format(date, "%m"), year = format(date, "%Y")) %>%
group_by(year, month, neighbourhood) %>%
summarise(num_reviews = n())
## create date column
df_grouped <- df_grouped %>% mutate(date = as.Date(paste0(year, "-", month, "-01")))
## store the final data frame in `gen/data-preparation` as `aggregated_df.csv`
write_csv(df_grouped, "aggregated_df.csv")
# CREATE PIVOT TABLE
## import the data from `gen/data-preparation/aggregated_df.csv`
df <- read_csv("aggregated_df.csv")
## create pivot table
df_pivot <- df %>%  pivot_wider(id_cols=date, names_from = neighbourhood, values_from = num_reviews)
## export results
write_csv(df_pivot, "pivot_table.csv")
# PLOT ANTWERP
## import the data from `gen/analysis/pivot_table`
df_pivot <- read_csv("pivot_table.csv")
pdf("plot_Antwerp.pdf")
library(tidyverse)
df_pivot <- read_csv("pivot_table.csv")
pdf("plot_Antwerp.pdf")
ggplot(df_pivot, aes(x = date)) +
geom_line(aes(y = Universiteitsbuurt, color = "Universiteitsbuurt"), linewidth = 1) +
geom_line(aes(y = `Sint-Andries`, color = "Sint-Andries"), linewidth = 1) +
geom_line(aes(y = `Centraal Station`, color = "Centraal Station"), linewidth = 1) +
labs(
x = "",
y = "Total number of reviews",
title = "Effect of COVID-19 pandemic on Airbnb review count",
color = "Neighborhood"
) +
scale_color_manual(values = c("Universiteitsbuurt" = "red",
"Sint-Andries" = "blue",
"Centraal Station" = "green")) +
theme_minimal()
dev.off()
# PLOT ALL
## import the data from `gen/data-preparation/aggregated_df.csv`
df <- read_csv("aggregated_df.csv")
## group by date and calculate the sum of all reviews across neighbourhoods.
df_groupby <- df %>% group_by(date) %>% summarise(num_reviews = sum(num_reviews))
## plot the chart and store the visualisation.
pdf("plot_all.pdf")
ggplot(df_groupby, aes(x = date, y = num_reviews)) +
geom_line(color = "black", size = 1) +
labs(
x = "",
y = "Total number of reviews",
title = "Effect of COVID-19 pandemic on Airbnb review count"
) +
theme_minimal()
dev.off()
# Load packages
library(tidyverse)
library(ggplot2)
# DOWNLOAD DATA
## Function to download data and save as CSV
download_data <- function(url, filename){
download.file(url = url, destfile = paste0(filename, ".csv"))
}
url_listings <- "http://data.insideairbnb.com/belgium/vlg/antwerp/2021-02-25/visualisations/listings.csv"
url_reviews <- "http://data.insideairbnb.com/belgium/vlg/antwerp/2021-02-25/visualisations/reviews.csv"
download_data(url_listings, "listings")
download_data(url_reviews, "reviews")
# CLEAN DATA
reviews <- read_csv("reviews.csv")
listings <- read_csv("listings.csv")
## filter for reviews published since 01/01/2015
reviews_filtered <- reviews %>% filter(date > "2015-01-01")
## filter for `listings` that have received at least 1 review.
listings_filtered <- listings %>% filter(number_of_reviews > 1)
## merge the `reviews` and `listings` dataframes on a common columns (the type of join doesn't really matter since we already filtered out listings without any reviews)
df_merged <- reviews_filtered %>% inner_join(listings_filtered, by = c("listing_id" = "id"))
## group the number of reviews by month and neighborhood.
df_grouped <- df_merged %>%
mutate(month = format(date, "%m"), year = format(date, "%Y")) %>%
group_by(year, month, neighbourhood) %>%
summarise(num_reviews = n())
## create date column
df_grouped <- df_grouped %>% mutate(date = as.Date(paste0(year, "-", month, "-01")))
## store the final data frame in `gen/data-preparation` as `aggregated_df.csv`
write_csv(df_grouped, "aggregated_df.csv")
# CREATE PIVOT TABLE
## import the data from `gen/data-preparation/aggregated_df.csv`
df <- read_csv("aggregated_df.csv")
## create pivot table
df_pivot <- df %>%  pivot_wider(id_cols=date, names_from = neighbourhood, values_from = num_reviews)
## export results
write_csv(df_pivot, "pivot_table.csv")
# PLOT ANTWERP
## import the data from `gen/analysis/pivot_table`
df_pivot <- read_csv("pivot_table.csv")
pdf("plot_Antwerp.pdf")
library(tidyverse)
df_pivot <- read_csv("pivot_table.csv")
pdf("plot_Antwerp.pdf")
ggplot(df_pivot, aes(x = date)) +
geom_line(aes(y = Stadspark, color = "Stadspark"), linewidth = 1) +
geom_line(aes(y = `Sint-Andries`, color = "Sint-Andries"), linewidth = 1) +
geom_line(aes(y = `Centraal Station`, color = "Centraal Station"), linewidth = 1) +
labs(
x = "",
y = "Total number of reviews",
title = "Effect of COVID-19 pandemic on Airbnb review count",
color = "Neighborhood"
) +
scale_color_manual(values = c("Stadspark" = "red",
"Sint-Andries" = "blue",
"Centraal Station" = "green")) +
theme_minimal()
dev.off()
# PLOT ALL
## import the data from `gen/data-preparation/aggregated_df.csv`
df <- read_csv("aggregated_df.csv")
## group by date and calculate the sum of all reviews across neighbourhoods.
df_groupby <- df %>% group_by(date) %>% summarise(num_reviews = sum(num_reviews))
## plot the chart and store the visualisation.
pdf("plot_all.pdf")
ggplot(df_groupby, aes(x = date, y = num_reviews)) +
geom_line(color = "black", size = 1) +
labs(
x = "",
y = "Total number of reviews",
title = "Effect of COVID-19 pandemic on Airbnb review count"
) +
theme_minimal()
dev.off()
setwd("~/Documents/Master/Data Prep. Programming Skills/Team project/Tutorial 5")
---
title: "Deliverable 4"
---
title: "Deliverable 4"
knitr::opts_chunk$set(
echo    = FALSE,
message = FALSE,
warning = FALSE,
fig.align = "center",
fig.width = 7, fig.height = 4, dpi = 180
)
options(tidyverse.quiet = TRUE)
need_pkgs <- c(
"tidyverse","data.table","readr","lubridate",
"knitr","kableExtra","broom"
)
# Optional (used only if you later add those features)
opt_pkgs <- c("ISOweek","zoo","janitor","gt")
missing <- setdiff(need_pkgs, rownames(installed.packages()))
if (length(missing)) {
stop(
sprintf("Please install missing packages before knitting: %s",
paste(missing, collapse = ", "))
)
}
cust <- read.csv("cust.csv", stringsAsFactors =
cust <- read.csv("cust.csv", stringsAsFactors = FALSE)
set.seed(90)
## 2) Random sample trekken (n = 2250) --------------------------------------
set.seed(90)
cust_s <- cust[sample.int(nrow(cust), 2250), ]
cust_s <- cust.csv[sample.int(nrow(cust), 2250), ]
cust_s <- cust.csv[sample.int(nrow(cust), 2250), ]
# Benodigde code om de vraag te beantwoorden
# 1) Data inlezen en sample trekken
cust <- read.csv("cust.csv", stringsAsFactors = FALSE)
# Benodigde code om de vraag te beantwoorden
# 1) Data inlezen en sample trekken
cust <- read.csv("cust.csv", stringsAsFactors = FALSE)
knitr::opts_chunk$set(
echo    = FALSE,
message = FALSE,
warning = FALSE,
fig.align = "center",
fig.width = 7, fig.height = 4, dpi = 180
)
options(tidyverse.quiet = TRUE)
need_pkgs <- c(
"tidyverse","data.table","readr","lubridate",
"knitr","kableExtra","broom"
)
install.packages("kableExtra")
# Optional (used only if you later add those features)
opt_pkgs <- c("ISOweek","zoo","janitor","gt")
missing <- setdiff(need_pkgs, rownames(installed.packages()))
if (length(missing)) {
stop(
sprintf("Please install missing packages before knitting: %s",
paste(missing, collapse = ", "))
)
}
invisible(lapply(need_pkgs, library, character.only = TRUE))
present_opt <- intersect(opt_pkgs, rownames(installed.packages()))
if (length(present_opt)) {
invisible(lapply(present_opt, library, character.only = TRUE))
}
summary(cars)
# Load IMDb title.basics data
basics <- fread("https://datasets.imdbws.com/title.basics.tsv.gz")
install.packages("kableExtra")
knitr::opts_chunk$set(
echo    = FALSE,
message = FALSE,
warning = FALSE,
fig.align = "center",
fig.width = 7, fig.height = 4, dpi = 180
)
options(tidyverse.quiet = TRUE)
need_pkgs <- c(
"tidyverse","data.table","readr","lubridate",
"knitr","kableExtra","broom"
)
install.packages("kableExtra")
# Optional (used only if you later add those features)
opt_pkgs <- c("ISOweek","zoo","janitor","gt")
missing <- setdiff(need_pkgs, rownames(installed.packages()))
if (length(missing)) {
stop(
sprintf("Please install missing packages before knitting: %s",
paste(missing, collapse = ", "))
)
}
invisible(lapply(need_pkgs, library, character.only = TRUE))
present_opt <- intersect(opt_pkgs, rownames(installed.packages()))
if (length(present_opt)) {
invisible(lapply(present_opt, library, character.only = TRUE))
}
summary(cars)
# Load IMDb title.basics data
basics <- fread("https://datasets.imdbws.com/title.basics.tsv.gz")
title.basics <- basics
# Load IMDb title.ratings data
title.ratings <- fread("https://datasets.imdbws.com/title.ratings.tsv.gz")
str(title.ratings)
# Summary of title.basics
fmt <- if (knitr::is_latex_output()) "latex" else "html"
snap <- tibble::tibble(
dataset = c("title.basics","title.ratings"),
n_rows  = c(nrow(title.basics), nrow(title.ratings)),
n_cols  = c(ncol(title.basics), ncol(title.ratings))
)
knitr::kable(snap, format = fmt, caption = "Data snapshots") |>
kableExtra::kable_styling(full_width = FALSE,
bootstrap_options = c("striped","hover","condensed"))
# Summary of title.ratings
dim(title.ratings)
nrow(title.ratings)
ncol(title.ratings)
colnames(title.ratings)
str(title.ratings)
summary(title.ratings)
head(title.ratings, 10)
# Variable table:
var_dict <- tribble(
~Variable,        ~Type,      ~Definition,                                                        ~Role,
"runtimeMinutes", "integer",  "Duration of the movie in minutes",                                 "Independent variable",
"averageRating",  "double",   "Average IMDb user rating (0–10 scale, aggregated from user votes)", "Dependent variable",
"startYear",      "integer",  "Year the movie was released",                                      "Control variable")
var_dict %>%
gt() %>%
tab_header(title = "Table 1. Variable Explanation") %>%
tab_options(column_labels.font.weight = "bold")
# Descriptive Statistics table:
data_final <- title.basics %>%
select(tconst, runtimeMinutes, startYear) %>%
mutate(
runtimeMinutes = suppressWarnings(as.numeric(runtimeMinutes)),
startYear      = suppressWarnings(as.integer(startYear))
) %>%
inner_join(
title.ratings %>% select(tconst, averageRating),
by = "tconst"
) %>%
mutate(averageRating = as.numeric(averageRating))
descriptives <- tibble(
Variable = c("runtimeMinutes","averageRating","startYear"),
N        = c(sum(!is.na(data_final$runtimeMinutes)),
sum(!is.na(data_final$averageRating)),
sum(!is.na(data_final$startYear))),
Missing  = c(sum(is.na(data_final$runtimeMinutes)),
sum(is.na(data_final$averageRating)),
sum(is.na(data_final$startYear))),
Mean     = c(mean(data_final$runtimeMinutes, na.rm = TRUE),
mean(data_final$averageRating,  na.rm = TRUE),
mean(data_final$startYear,      na.rm = TRUE)),
SD       = c(sd(data_final$runtimeMinutes, na.rm = TRUE),
sd(data_final$averageRating,  na.rm = TRUE),
sd(data_final$startYear,      na.rm = TRUE)),
Min      = c(min(data_final$runtimeMinutes, na.rm = TRUE),
min(data_final$averageRating,  na.rm = TRUE),
min(data_final$startYear,      na.rm = TRUE)),
Max      = c(max(data_final$runtimeMinutes, na.rm = TRUE),
max(data_final$averageRating,  na.rm = TRUE),
max(data_final$startYear,      na.rm = TRUE)))
descriptives %>%
gt() %>%
tab_header(title = "Table 2. Descriptive Statistics") %>%
tab_options(column_labels.font.weight="bold")
# Data preparation point 2.2
current_year <- 2025
max_runtime  <- 300
>>>>>>> Stashed changes
to_na <- function(x) {
y <- as.character(x)
y[y %in% c("\\N", "N", "")] <- NA_character_
y
}
<<<<<<< Updated upstream
# Cleaning the titile.basics dataset
title.basics_clean <- title.basics %>%
mutate(across(c(titleType, primaryTitle, startYear, runtimeMinutes), to_na)) %>%
mutate(startYear = suppressWarnings(as.integer(startYear)),
runtimeMinutes = suppressWarnings(as.numeric(runtimeMinutes))) %>%
select(tconst, titleType, primaryTitle, originalTitle, isAdult,
startYear, endYear, runtimeMinutes, genres) %>%
distinct(tconst, .keep_all = TRUE)
# Cleaning the title.ratings dataset
title.ratings_clean <- title.ratings %>%
mutate(across(c(averageRating, numVotes), to_na)) %>%
mutate(averageRating = as.numeric(averageRating),
numVotes = as.integer(numVotes)) %>%
select(tconst, averageRating, numVotes) %>%
distinct(tconst, .keep_all = TRUE)
# Verification of variable types after the cleaning
dplyr::glimpse(title.basics_clean[, c("primaryTitle", "startYear", "runtimeMinutes")])
sapply(title.basics_clean[, c("primaryTitle", "startYear", "runtimeMinutes")], typeof)
dplyr::glimpse(title.ratings_clean[, "averageRating", drop = FALSE])
sapply(title.ratings_clean[, "averageRating", drop = FALSE], typeof)
# Checking missing values
colSums(is.na(title.basics_clean[, c("primaryTitle", "startYear", "runtimeMinutes")]))
colSums(is.na(title.ratings_clean[, c("averageRating", "numVotes")]))
# Variable table:
var_dict <- tribble(
~Variable,  ~Class, ~Definition, ~Role,
"runtimeMinutes", "numeric",  "Duration of the movie in minutes", "Independent variable",
"averageRating",  "numeric",   "Average IMDb user rating (0–10 scale, aggregated from user votes)", "Dependent variable",
"startYear",      "numeric",  "Year the movie was released", "Control variable")
var_dict %>%
gt() %>%
tab_header(title = "Table 1. Variable Explanation") %>%
tab_options(column_labels.font.weight = "bold")
### Checking for outliers in IMDb ratings
# Numeric summary of average ratings
summary(title.ratings_clean$averageRating)
# Histogram of rating distribution (excluding missing values)
ratings_clean <- dplyr::filter(title.ratings_clean, !is.na(averageRating))
ggplot(ratings_clean, aes(x = averageRating)) +
geom_histogram(binwidth = 0.25, color = "white", fill = "grey30", boundary = 0) +
scale_x_continuous(limits = c(0, 10), breaks = 0:10) +
labs(
x = "Average rating",
y = "Count",
title = "Distribution of IMDb Ratings"
) +
theme_minimal(base_size = 14)
# Filter for movies only (and reasonable ranges)
title.basics_filtered <- title.basics_clean %>%
filter(titleType == "movie",
runtimeMinutes >40,
runtimeMinutes <= 300,
startYear <= 2025) %>%
select(tconst, primaryTitle, startYear, runtimeMinutes) %>%
distinct(tconst, .keep_all = TRUE)
```{r Data Preparation}
title.basics_filtered <- title.basics_clean %>%
filter(
titleType %in% c("movie", "tvMovie"),
runtimeMinutes > 40,
runtimeMinutes <= 300,
startYear <= 2025
) %>%
select(tconst, primaryTitle, startYear, runtimeMinutes) %>%
distinct(tconst, .keep_all = TRUE)
# Renaming variables
title.basics_filtered <- title.basics_filtered %>%
rename(
title           = primaryTitle,
start_year      = startYear,
runtime_minutes = runtimeMinutes)
title.ratings_clean <- title.ratings_clean %>%
rename(
average_rating  = averageRating,
votes           = numVotes)
# Merging datasets
merged_data <- title.basics_filtered %>%
select(tconst, runtime_minutes, start_year, title) %>%
mutate(
runtime_minutes = (as.numeric(runtime_minutes)),
start_year      = (as.integer(start_year)),
title = (as.character(title))) %>%
inner_join(
title.ratings_clean %>% select(tconst, average_rating, votes),
by = "tconst") %>%
mutate(
average_rating = as.numeric(average_rating),
votes= as.integer(votes))
# Checking the duplicated data
keys <- c("title", "start_year", "runtime_minutes")
dup_count <- sum(duplicated(select(merged_data, all_of(keys))))
dup_count
duplicated_movies <- merged_data %>%
mutate(is_duplicate = duplicated(select(., all_of(keys))) |
duplicated(select(., all_of(keys)), fromLast = TRUE)) %>%
filter(is_duplicate) %>%
select(title, start_year, runtime_minutes, average_rating, votes) %>%
arrange(title, start_year, runtime_minutes)
# Count duplicate groups (titles that appear multiple times)
duplicate_summary <- merged_data %>%
count(across(all_of(keys)), sort = TRUE) %>%
filter(n > 1) %>% slice_head(n = 20)
duplicate_summary
# Handling Duplicates - retaining only one record per movie, the one with highest number of votes
movies_deduplicated <- merged_data %>%
group_by(across(all_of(keys))) %>%
slice_max(votes, with_ties = FALSE) %>%
ungroup()
# Verification
sum(duplicated(select(movies_deduplicated, all_of(keys))))
## Handling missing data
colSums(is.na(movies_deduplicated[, c("runtime_minutes", "average_rating", "start_year", "title")]))
summary(movies_deduplicated)
movies_final_clean <- movies_deduplicated
# Descriptive table
descriptives <- tibble(
Variable = c("runtime_minutes","average_rating","start_year"),
N        = c(sum(!is.na(movies_final_clean$runtime_minutes)),
sum(!is.na(movies_final_clean$average_rating)),
sum(!is.na(movies_final_clean$start_year))),
Missing  = c(sum(is.na(movies_final_clean$runtime_minutes)),
sum(is.na(movies_final_clean$average_rating)),
sum(is.na(movies_final_clean$start_year))),
Mean     = c(mean(movies_final_clean$runtime_minutes, na.rm = TRUE),
mean(movies_final_clean$average_rating,  na.rm = TRUE),
mean(movies_final_clean$start_year,      na.rm = TRUE)),
SD       = c(sd(movies_final_clean$runtime_minutes, na.rm = TRUE),
sd(movies_final_clean$average_rating,  na.rm = TRUE),
sd(movies_final_clean$start_year,      na.rm = TRUE)),
Min      = c(min(movies_final_clean$runtime_minutes, na.rm = TRUE),
min(movies_final_clean$average_rating,  na.rm = TRUE),
min(movies_final_clean$start_year,      na.rm = TRUE)),
Max      = c(max(movies_final_clean$runtime_minutes, na.rm = TRUE),
max(movies_final_clean$average_rating,  na.rm = TRUE),
max(movies_final_clean$start_year,      na.rm = TRUE)))
descriptives %>%
gt() %>%
tab_header(title = "Table 2. Descriptive Statistics") %>%
tab_options(column_labels.font.weight="bold")
model_1 <- lm(average_rating ~ runtime_minutes + start_year, data = movies_final_clean)
summary(model_1)
model_2 <- lm(average_rating ~ runtime_minutes * start_year, data = movies_final_clean)
summary(model_2)
ggplot(movies_final_clean, aes(x = start_year, y = average_rating)) +
geom_point(alpha = 0.1, color = "grey20") +
geom_smooth(method = "lm", color = "red3", size = 1.2) +
labs(
title = "Relationship Between Release Year and IMDb Ratings",
x = "Release Year",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 8)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating, color = start_year)) +
geom_point(alpha = 0.1) +
geom_smooth(method = "lm", se = FALSE) +
labs(
title = "Interaction between Runtime and Release Year on IMDb Ratings",
x = "Runtime (minutes)",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 8)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.1) +
geom_smooth(method = "lm", color = "red", se = FALSE) +
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.1, color = "#1f77b4") +  # ładny, stonowany niebieski
geom_smooth(method = "lm", color = "#d62728", se = FALSE) +  # czerwonawy trend
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.15, color = "#2C3E50") +  # granatowy
geom_smooth(method = "lm", color = "#E67E22", se = FALSE) +  # pomarańczowy trend
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +  # pastelowy błękit
geom_smooth(method = "lm", color = "#1A5276", se = FALSE) +  # ciemniejszy niebieski trend
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
ggplot(movies_final_clean, aes(x = start_year, y = average_rating)) +
geom_point(alpha = 0.15, color = "#1f77b4") +   # jasnoniebieskie punkty
geom_smooth(method = "lm", se = FALSE, color = "#d62728", size = 1.2) +  # czerwonawy trend
labs(
title = "Relationship between Release Year and IMDb Rating",
x = "Release Year",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 12)
library(ggeffects)
# Analysis, linear regression
library(lmtest)
library(sandwich)
# robust SE (HC3 is the most conservative and widely used)
coeftest(model_1, vcov = vcovHC(model_1, type = "HC3"))
model_1 <- lm(average_rating ~ runtime_minutes + start_year, data = movies_final_clean)
summary(model_1)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +  # pastelowy błękit
geom_smooth(method = "lm", color = "#1A5276", se = FALSE) +  # ciemniejszy niebieski trend
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
model_2 <- lm(average_rating ~ runtime_minutes * start_year, data = movies_final_clean)
summary(model_2)
ggplot(movies_final_clean, aes(x = start_year, y = average_rating)) +
geom_point(alpha = 0.15, color = "#1f77b4") +   # jasnoniebieskie punkty
geom_smooth(method = "lm", se = FALSE, color = "#d62728", size = 1.2) +  # czerwonawy trend
labs(
title = "Relationship between Release Year and IMDb Rating",
x = "Release Year",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 12)
# Analysis, linear regression
model_1 <- lm(average_rating ~ runtime_minutes + start_year, data = movies_final_clean)
summary(model_1)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +  # pastelowy błękit
geom_smooth(method = "lm", color = "#1A5276", se = FALSE) +  # ciemniejszy niebieski trend
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
model_2 <- lm(average_rating ~ runtime_minutes * start_year, data = movies_final_clean)
summary(model_2)
ggplot(movies_final_clean, aes(x = start_year, y = average_rating)) +
geom_point(alpha = 0.15, color = "#1f77b4") +   # jasnoniebieskie punkty
geom_smooth(method = "lm", se = FALSE, color = "#d62728", size = 1.2) +  # czerwonawy trend
labs(
title = "Relationship between Release Year and IMDb Rating",
x = "Release Year",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 12)
# Analysis, linear regression
model_1 <- lm(average_rating ~ runtime_minutes + start_year, data = movies_final_clean)
summary(model_1)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +  # pastelowy błękit
geom_smooth(method = "lm", color = "#1A5276", se = FALSE) +  # ciemniejszy niebieski trend
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
model_2 <- lm(average_rating ~ runtime_minutes * start_year, data = movies_final_clean)
summary(model_2)
ggplot(movies_final_clean, aes(x = start_year, y = average_rating)) +
geom_point(alpha = 0.2, color = "#1f77b4") +   # jasnoniebieskie punkty
geom_smooth(method = "lm", se = FALSE, color = "#d62728", size = 1.2) +  # czerwonawy trend
labs(
title = "Relationship between Release Year and IMDb Rating",
x = "Release Year",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 12)
# Get predicted ratings while controlling for year
pred <- ggpredict(model_1, terms = "runtime_minutes [all]")
install.packages("ggeffects")
library(ggeffects)
# Get predicted ratings while controlling for year
pred <- ggpredict(model_1, terms = "runtime_minutes [all]")
ggplot(pred, aes(x = x, y = predicted)) +
geom_line(color = "#1A5276", size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#5DADE2", alpha = 0.3) +
labs(
title = "Predicted IMDb Rating vs Runtime (controlling for Release Year)",
x = "Runtime (minutes)",
y = "Predicted IMDb Rating"
) +
theme_minimal(base_size = 12)
library(modelsummary)
library(sandwich)
VHC3 <- sandwich::vcovHC(model_1, type = "HC3")
msummary(model_1,
vcov = VHC3,
stars = TRUE,
gof_omit = "IC|AIC|BIC",
coef_map = c(
"(Intercept)" = "Intercept",
"runtime_minutes" = "Runtime (minutes)",
"start_year" = "Release year"
),
title = "Table 3. OLS regression: IMDb ratings on runtime (controlling for release year)")
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Relationship between Runtime and IMDb Rating",
subtitle = "OLS regression controlling for release year",
x = "Runtime (minutes)",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 14),
plot.subtitle = element_text(size = 11)
)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE) +
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
model_quad <- lm(average_rating ~ runtime_minutes + I(runtime_minutes^2) + start_year, data = movies_final_clean)
summary(model_quad)
library(modelsummary)
msummary(list("Linear model" = model_1, "Quadratic model" = model_quad),
stars = TRUE,
gof_omit = "IC|AIC|BIC",
title = "Comparison of Linear and Quadratic Models")
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.1, color = "#AED6F1") +
geom_smooth(method = "lm", formula = y ~ x, color = "#1A5276", se = FALSE, size = 1.1) +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "#E74C3C", se = FALSE, size = 1.1) +
labs(
title = "Linear vs Quadratic Fit: Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating",
caption = "Blue = linear model; Red = quadratic model"
) +
theme_minimal(base_size = 13)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.1, color = "#AED6F1") +
geom_smooth(method = "lm", formula = y ~ x, color = "#1A5276", se = FALSE, size = 1.1) +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "#E74C3C", se = FALSE, size = 1.1) +
coord_cartesian(xlim = c(40, 250), ylim = c(0, 10)) +
labs(
title = "Linear vs Quadratic Fit: Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating",
caption = "Blue = linear model; Red = quadratic model (predictions capped to data range)"
) +
theme_minimal(base_size = 13)
library(ggeffects)
library(ggplot2)
# (1) Simple raw relationship
p1 <- ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Runtime and IMDb Rating (Raw Relationship)",
x = "Runtime (minutes)",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 13)
# (2) Model-adjusted relationship controlling for release year
pred <- ggpredict(model_1, terms = "runtime_minutes [all]")
p2 <- ggplot(pred, aes(x = x, y = predicted)) +
geom_line(color = "#1A5276", size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#5DADE2", alpha = 0.3) +
labs(
title = "Predicted IMDb Rating vs Runtime",
subtitle = "Controlling for release year (OLS regression)",
x = "Runtime (minutes)",
y = "Predicted IMDb Rating"
) +
theme_minimal(base_size = 13)
p1
p2
library(ggeffects)
library(ggplot2)
# (1) Simple raw relationship
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 13)
# (2) Model-adjusted relationship controlling for release year
pred <- ggpredict(model_1, terms = "runtime_minutes [all]")
ggplot(pred, aes(x = x, y = predicted)) +
geom_line(color = "#1A5276", size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#5DADE2", alpha = 0.2) +
labs(
title = "Predicted IMDb Rating vs Runtime",
subtitle = "Controlling for release year (OLS regression)",
x = "Runtime (minutes)",
y = "Predicted IMDb Rating"
) +
theme_minimal(base_size = 13)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Relationship between Runtime and IMDb Rating",
subtitle = "OLS regression controlling for release year",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 14),
plot.subtitle = element_text(size = 11))
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Relationship between Runtime and IMDb Rating",
subtitle = "OLS regression controlling for release year",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 14),
plot.subtitle = element_text(size = 11))
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE) +
labs(title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 12)
#Simple relationship
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating"
) +
theme_minimal(base_size = 13)
#Model-adjusted relationship controlling for release year
pred <- ggpredict(model_1, terms = "runtime_minutes [all]")
ggplot(pred, aes(x = x, y = predicted)) +
geom_line(color = "#1A5276", size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#5DADE2", alpha = 0.2) +
labs(
title = "Predicted IMDb Rating vs Runtime",
subtitle = "Controlling for release year (OLS regression)",
x = "Runtime (minutes)",
y = "Predicted IMDb Rating"
) +
theme_minimal(base_size = 13)
## Regression Analysis
# Baseline OLS regression
model_1 <- lm(average_rating ~ runtime_minutes + start_year, data = movies_final_clean)
summary(model_1)
# Simple relationship visualization
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#5DADE2") +
geom_smooth(method = "lm", color = "#1A5276", se = FALSE, size = 1.2) +
labs(
title = "Relationship between Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating") +
theme_minimal(base_size = 13)
# Predicted relationship (controlling for release year)
pred <- ggpredict(model_1, terms = "runtime_minutes [all]")
ggplot(pred, aes(x = x, y = predicted)) +
geom_line(color = "#1A5276", size = 1.2) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "#5DADE2", alpha = 0.2) +
labs(
title = "Predicted IMDb Rating vs Runtime",
subtitle = "Controlling for release year (OLS regression)",
x = "Runtime (minutes)",
y = "Predicted IMDb Rating"
) +
theme_minimal(base_size = 13)
# Quadratic model (testing nonlinearity)
model_quad <- lm(average_rating ~ runtime_minutes + I(runtime_minutes^2) + start_year, data = movies_final_clean)
summary(model_quad)
ggplot(movies_final_clean, aes(x = runtime_minutes, y = average_rating)) +
geom_point(alpha = 0.2, color = "#AED6F1") +
geom_smooth(method = "lm", formula = y ~ x, color = "#1A5276", se = FALSE, size = 1.1) +
geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "#E74C3C", se = FALSE, size = 1.1) +
coord_cartesian(xlim = c(40, 250), ylim = c(0, 10)) +
labs(
title = "Linear vs Quadratic Fit: Runtime and IMDb Rating",
x = "Runtime (minutes)",
y = "Average IMDb Rating",
caption = "Blue = linear model; Red = quadratic model (predictions capped to data range)"
) +
theme_minimal(base_size = 13)
# Robustness Check - interaction with release year
model_2 <- lm(average_rating ~ runtime_minutes * start_year, data = movies_final_clean)
summary(model_2)
=======
title.basics_clean <- title.basics %>%
mutate(
titleType      = to_na(titleType),
primaryTitle   = to_na(primaryTitle),
startYear      = to_na(startYear),
runtimeMinutes = to_na(runtimeMinutes)) %>%
mutate(
startYear      = suppressWarnings(as.integer(startYear)),
runtimeMinutes = suppressWarnings(as.numeric(runtimeMinutes))) %>%
filter(titleType == "movie") %>%
select(tconst, primaryTitle, startYear, runtimeMinutes) %>%
distinct(tconst, .keep_all = TRUE)
title.ratings_clean <- title.ratings %>%
mutate(
averageRating = to_na(averageRating),
numVotes      = to_na(numVotes)) %>%
mutate(averageRating = as.numeric(averageRating),
numVotes      = as.integer(numVotes)) %>%
select(tconst, averageRating, numVotes) %>%
distinct(tconst, .keep_all = TRUE)
movies_final <- title.basics_clean %>%
inner_join(title.ratings_clean, by = "tconst") %>%
filter(!is.na(runtimeMinutes),
!is.na(averageRating),
!is.na(startYear)) %>%
filter(runtimeMinutes > 0,
runtimeMinutes <= max_runtime) %>%
filter(startYear <= current_year) %>%
rename(
title           = primaryTitle,
start_year      = startYear,
runtime_minutes = runtimeMinutes,
average_rating  = averageRating,
votes           = numVotes)
list(
n_rows = nrow(movies_final),
min_runtime = min(movies_final$runtime_minutes),
max_runtime = max(movies_final$runtime_minutes),
min_year = min(movies_final$start_year),
max_year = max(movies_final$start_year),
any_na = anyNA(movies_final[, c("runtime_minutes","average_rating","start_year")]))
fmt <- if (knitr::is_latex_output()) "latex" else "html"
tibble(
metric = c("rows","min_runtime","max_runtime","min_year","max_year","any_na"),
value  = c(nrow(movies_final),
min(movies_final$runtime_minutes),
max(movies_final$runtime_minutes),
min(movies_final$start_year),
max(movies_final$start_year),
anyNA(movies_final[, c("runtime_minutes","average_rating","start_year")]))
) |>
knitr::kable(format = fmt, caption = "Quick data checks") |>
kableExtra::kable_styling(full_width = FALSE)
movies_dt <- as.data.table(movies_final)
yearly_dt <- movies_dt[
, .(
n_movies    = .N,
avg_runtime = mean(runtime_minutes),
avg_rating  = mean(average_rating),
med_votes   = median(votes)
),
by = start_year
][order(start_year)]
movies_dt[
, runtime_bin := cut(runtime_minutes, breaks = c(1, 90, 120, 150, 180, 300),
right = TRUE, include.lowest = TRUE)
]
runtime_summary_dt <- movies_dt[
, .(
n = .N,
wmean_rating = weighted.mean(average_rating, w = pmax(votes, 1))
),
by = runtime_bin
][order(runtime_bin)]
setkey(movies_dt, start_year)
fmt <- if (knitr::is_latex_output()) "latex" else "html"
cap1 <- if (knitr::is_latex_output()) "Preview: yearly\\_dt (first 10)" else "Preview: yearly_dt (first 10)"
cap2 <- if (knitr::is_latex_output()) "Preview: runtime\\_summary\\_dt (first 10)" else "Preview: runtime_summary_dt (first 10)"
knitr::kable(
head(yearly_dt, 10),
format  = fmt,
caption = cap1,
escape  = TRUE
) |>
kableExtra::kable_styling(full_width = FALSE,
bootstrap_options = c("striped","hover","condensed"))
knitr::kable(
head(runtime_summary_dt, 10),
format  = fmt,
caption = cap2,
escape  = TRUE
) |>
kableExtra::kable_styling(full_width = FALSE,
bootstrap_options = c("striped","hover","condensed"))
fmt <- if (knitr::is_latex_output()) "latex" else "html"
movies_final |>
count(start_year, name = "n_movies") |>
arrange(start_year) |>
knitr::kable(format = fmt, caption = "Number of movies by release year") |>
kableExtra::kable_styling(full_width = FALSE,
bootstrap_options = c("striped","hover","condensed"))
movies_eng <- movies_final |>
mutate(
start_year   = as.integer(start_year),
decade       = 10 * (start_year %/% 10),
runtime_bin  = cut(runtime_minutes,
breaks = c(0, 60, 90, 120, 150, Inf),
labels = c("<=60","60–90","90–120","120–150",">150"),
include.lowest = TRUE, right = TRUE),
log_votes    = log1p(votes)
)
movies_eng <- movies_eng |>
group_by(start_year) |>
mutate(
runtime_imp        = ifelse(is.na(runtime_minutes),
median(runtime_minutes, na.rm = TRUE),
runtime_minutes),
average_rating_imp = ifelse(is.na(average_rating),
median(average_rating, na.rm = TRUE),
average_rating)
) |>
ungroup()
movies_wide <- movies_eng |>
mutate(rating_bucket = cut(average_rating_imp,
breaks = c(0,4,6,7,8,10),
labels = c("<4","4–6","6–7","7–8",">=8"),
include.lowest = TRUE)) |>
count(start_year, rating_bucket, name = "n") |>
tidyr::pivot_wider(names_from = rating_bucket, values_from = n, values_fill = 0)
# Pretty preview (first 10 years)
fmt <- if (knitr::is_latex_output()) "latex" else "html"
knitr::kable(head(movies_wide, 10), format = fmt,
caption = "Movies per rating bucket by year (wide)") |>
kableExtra::kable_styling(full_width = FALSE,
bootstrap_options = c("striped","hover","condensed"))
yearly <- movies_eng |>
group_by(start_year) |>
summarise(
avg_rating  = mean(average_rating_imp, na.rm = TRUE),
avg_runtime = mean(runtime_imp, na.rm = TRUE),
n_movies    = n(),
.groups = "drop"
) |>
arrange(start_year) |>
mutate(trend = row_number())
movies_eng |>
filter(!is.na(runtime_imp), !is.na(average_rating_imp)) |>
ggplot(aes(x = runtime_imp, y = average_rating_imp)) +
geom_point(alpha = 0.3) +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Runtime vs. Rating",
x = "Runtime (minutes, imputed)",
y = "Average rating (imputed)")
mod <- lm(average_rating_imp ~ runtime_imp + factor(start_year), data = movies_eng)
broom::tidy(mod) |>
knitr::kable(format = if (knitr::is_latex_output()) "latex" else "html",
caption = "OLS: rating on runtime + year fixed effects") |>
kableExtra::kable_styling(full_width = FALSE,
bootstrap_options = c("striped","hover","condensed"))
adoption <- read.table("~/Downloads/adoption.sav", quote="\"")
---
title: "Deliverable 5"
# Research Motivation
Please follow the installation guides on <http://tilburgsciencehub.com/>.
>>>>>>> Stashed changes
